<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>HTTPS系列干货（一）</title>
      <link href="/2020/04/04/HTTPS1/"/>
      <url>/2020/04/04/HTTPS1/</url>
      
        <content type="html"><![CDATA[<h2 id="HTTPS（全称：HyperText-Transfer-Protocol-over-Secure-Socket-Layer）"><a href="#HTTPS（全称：HyperText-Transfer-Protocol-over-Secure-Socket-Layer）" class="headerlink" title="HTTPS（全称：HyperText Transfer Protocol over Secure Socket Layer）"></a>HTTPS（全称：HyperText Transfer Protocol over Secure Socket Layer）</h2><blockquote><p>其实 HTTPS 并不是一个新鲜协议，Google 很早就开始启用了，初衷是为了保证数据安全。 近两年，Google、Baidu、Facebook 等这样的互联网巨头，不谋而合地开始大力推行 HTTPS， 国内外的大型互联网公司很多也都已经启用了全站 HTTPS，这也是未来互联网发展的趋势。</p></blockquote><p>为鼓励全球网站的 HTTPS 实现，一些互联网公司都提出了自己的要求：</p><p>1）Google 已调整搜索引擎算法，让采用 HTTPS 的网站在搜索中排名更靠前；</p><p>2）从 2017 年开始，Chrome 浏览器已把采用 HTTP 协议的网站标记为不安全网站；</p><p>3）苹果要求 2017 年 App Store 中的所有应用都必须使用 HTTPS 加密连接；</p><p>4）当前国内炒的很火热的微信小程序也要求必须使用 HTTPS 协议；</p><p>5）新一代的 HTTP/2 协议的支持需以 HTTPS 为基础。</p><p>等等，因此想必在不久的将来，全网 HTTPS 势在必行。</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><h4 id="1、HTTP-协议（HyperText-Transfer-Protocol，超文本传输协议）"><a href="#1、HTTP-协议（HyperText-Transfer-Protocol，超文本传输协议）" class="headerlink" title="1、HTTP 协议（HyperText Transfer Protocol，超文本传输协议）"></a>1、HTTP 协议（HyperText Transfer Protocol，超文本传输协议）</h4><p>客户端浏览器或其他程序与Web服务器之间的应用层通信协议 。</p><h4 id="2、HTTPS-协议（HyperText-Transfer-Protocol-over-Secure-Socket-Layer）"><a href="#2、HTTPS-协议（HyperText-Transfer-Protocol-over-Secure-Socket-Layer）" class="headerlink" title="2、HTTPS 协议（HyperText Transfer Protocol over Secure Socket Layer）"></a>2、HTTPS 协议（HyperText Transfer Protocol over Secure Socket Layer）</h4><p>可以理解为HTTP+SSL/TLS， 即 HTTP 下加入 SSL 层，HTTPS 的安全基础是 SSL，因此加密的详细内容就需要 SSL，用于安全的 HTTP 数据传输。<br><img src="https://pic1.zhimg.com/80/v2-54ff04e1b0cc698f08f76d6356f59fac_720w.png" alt="HTTP"></p><p>如上图所示 HTTPS 相比 HTTP 多了一层 SSL/TLS</p><p>SSL（Secure Socket Layer，安全套接字层）：1994年为 Netscape 所研发，SSL 协议位于 TCP/IP 协议与各种应用层协议之间，为数据通讯提供安全支持。</p><p>TLS（Transport Layer Security，传输层安全）：其前身是 SSL，它最初的几个版本（SSL 1.0、SSL 2.0、SSL 3.0）由网景公司开发，1999年从 3.1 开始被 IETF 标准化并改名，发展至今已经有 TLS 1.0、TLS 1.1、TLS 1.2 三个版本。SSL3.0和TLS1.0由于存在安全漏洞，已经很少被使用到。TLS 1.3 改动会比较大，目前还在草案阶段，目前使用最广泛的是TLS 1.1、TLS 1.2。</p><h3 id="加密算法："><a href="#加密算法：" class="headerlink" title="加密算法："></a>加密算法：</h3><p>据记载，公元前400年，古希腊人就发明了置换密码；在第二次世界大战期间，德国军方启用了“恩尼格玛”密码机，所以密码学在社会发展中有着广泛的用途。</p><h4 id="1、对称加密"><a href="#1、对称加密" class="headerlink" title="1、对称加密"></a>1、对称加密</h4><p>有流式、分组两种，加密和解密都是使用的同一个密钥。<br>例如：DES、AES-GCM、ChaCha20-Poly1305等</p><h4 id="2、非对称加密"><a href="#2、非对称加密" class="headerlink" title="2、非对称加密"></a>2、非对称加密</h4><p>加密使用的密钥和解密使用的密钥是不相同的，分别称为：公钥、私钥，公钥和算法都是公开的，私钥是保密的。非对称加密算法性能较低，但是安全性超强，由于其加密特性，非对称加密算法能加密的数据长度也是有限的。<br>例如：RSA、DSA、ECDSA、 DH、ECDHE</p><h4 id="3、哈希算法"><a href="#3、哈希算法" class="headerlink" title="3、哈希算法"></a>3、哈希算法</h4><p>将任意长度的信息转换为较短的固定长度的值，通常其长度要比信息小得多，且算法不可逆。<br>例如：MD5、SHA-1、SHA-2、SHA-256 等</p><h4 id="4、数字签名"><a href="#4、数字签名" class="headerlink" title="4、数字签名"></a>4、数字签名</h4><p>签名就是在信息的后面再加上一段内容（信息经过hash后的值），可以证明信息没有被修改过。hash值一般都会加密后（也就是签名）再和信息一起发送，以保证这个hash值不被修改。</p><h2 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h2><h3 id="一、HTTP-访问过程"><a href="#一、HTTP-访问过程" class="headerlink" title="一、HTTP 访问过程"></a>一、HTTP 访问过程</h3><p><img src="https://pic4.zhimg.com/80/v2-e367a5e3bc28fb7fd083ddc201e7e693_720w.png" alt="http"><br>抓包如下：<br><img src="https://pic1.zhimg.com/80/v2-5fbdde93cf2db19730f9e90347614e64_720w.png" alt="http1"><br>如上图所示，HTTP请求过程中，客户端与服务器之间没有任何身份确认的过程，数据全部明文传输，“裸奔”在互联网上，所以很容易遭到黑客的攻击，如下：<br><img src="https://pic4.zhimg.com/80/v2-831635f04f3732e866af0ec6ce1040e7_720w.png" alt="http2"><br>可以看到，客户端发出的请求很容易被黑客截获，如果此时黑客冒充服务器，则其可返回任意信息给客户端，而不被客户端察觉，所以我们经常会听到一词“劫持”，现象如下：</p><p>下面两图中，浏览器中填入的是相同的URL，左边是正确响应，而右边则是被劫持后的响应<br><img src="https://pic4.zhimg.com/80/v2-299b4a71f9b005fa15fbcd4cabfd841b_720w.png" alt="http2"><br>所以 HTTP 传输面临的风险有：<br>（1） 窃听风险：黑客可以获知通信内容。<br>（2） 篡改风险：黑客可以修改通信内容。<br>（3） 冒充风险：黑客可以冒充他人身份参与通信。</p><h3 id="二、HTTP-向-HTTPS-演化的过程"><a href="#二、HTTP-向-HTTPS-演化的过程" class="headerlink" title="二、HTTP 向 HTTPS 演化的过程"></a>二、HTTP 向 HTTPS 演化的过程</h3><h4 id="第一步：为了防止上述现象的发生，人们想到一个办法：对传输的信息加密（即使黑客截获，也无法破解）"><a href="#第一步：为了防止上述现象的发生，人们想到一个办法：对传输的信息加密（即使黑客截获，也无法破解）" class="headerlink" title="第一步：为了防止上述现象的发生，人们想到一个办法：对传输的信息加密（即使黑客截获，也无法破解）"></a>第一步：为了防止上述现象的发生，人们想到一个办法：对传输的信息加密（即使黑客截获，也无法破解）</h4><p><img src="https://pic1.zhimg.com/80/v2-8d8138e883455e4d316d644c79a89314_720w.png" alt="http2"><br>如上图所示，此种方式属于对称加密，双方拥有相同的密钥，信息得到安全传输，但此种方式的缺点是：<br>（1）不同的客户端、服务器数量庞大，所以双方都需要维护大量的密钥，维护成本很高<br>（2）因每个客户端、服务器的安全级别不同，密钥极易泄露</p><h4 id="第二步：既然使用对称加密时，密钥维护这么繁琐，那我们就用非对称加密试试"><a href="#第二步：既然使用对称加密时，密钥维护这么繁琐，那我们就用非对称加密试试" class="headerlink" title="第二步：既然使用对称加密时，密钥维护这么繁琐，那我们就用非对称加密试试"></a>第二步：既然使用对称加密时，密钥维护这么繁琐，那我们就用非对称加密试试</h4><p><img src="https://pic2.zhimg.com/80/v2-660bec42419281a9ec47c029089a77c9_720w.png" alt="http2"><br>如上图所示，客户端用公钥对请求内容加密，服务器使用私钥对内容解密，反之亦然，但上述过程也存在缺点：<br>（1）公钥是公开的（也就是黑客也会有公钥），所以第 ④ 步私钥加密的信息，如果被黑客截获，其可以使用公钥进行解密，获取其中的内容</p><h4 id="第三步：非对称加密既然也有缺陷，那我们就将对称加密，非对称加密两者结合起来，取其精华、去其糟粕，发挥两者的各自的优势"><a href="#第三步：非对称加密既然也有缺陷，那我们就将对称加密，非对称加密两者结合起来，取其精华、去其糟粕，发挥两者的各自的优势" class="headerlink" title="第三步：非对称加密既然也有缺陷，那我们就将对称加密，非对称加密两者结合起来，取其精华、去其糟粕，发挥两者的各自的优势"></a>第三步：非对称加密既然也有缺陷，那我们就将对称加密，非对称加密两者结合起来，取其精华、去其糟粕，发挥两者的各自的优势</h4><p><img src="https://pic3.zhimg.com/80/v2-22570e3e422de7951ce7c5c3e8435312_720w.png" alt="http2"></p><ul><li><p>如上图所示<br>（1）第③步时，客户端说：（咱们后续回话采用对称加密吧，这是对称加密的算法和对称密钥）这段话用公钥进行加密，然后传给服务器<br>（2）服务器收到信息后，用私钥解密，提取出对称加密算法和对称密钥后，服务器说：（好的）对称密钥加密<br>（3）后续两者之间信息的传输就可以使用对称加密的方式了</p></li><li><p>遇到的问题：<br>（1）客户端如何获得公钥<br>（2）如何确认服务器是真实的而不是黑客</p><h4 id="第四步：获取公钥与确认服务器身份"><a href="#第四步：获取公钥与确认服务器身份" class="headerlink" title="第四步：获取公钥与确认服务器身份"></a>第四步：获取公钥与确认服务器身份</h4><p><img src="https://pic3.zhimg.com/80/v2-f2ac6567fa1a3c10e73eba59eab3823a_720w.png" alt="http2"></p><h5 id="1、获取公钥"><a href="#1、获取公钥" class="headerlink" title="1、获取公钥"></a>1、获取公钥</h5><p>（1）提供一个下载公钥的地址，回话前让客户端去下载。（缺点：下载地址有可能是假的；客户端每次在回话前都先去下载公钥也很麻烦）<br>（2）回话开始时，服务器把公钥发给客户端（缺点：黑客冒充服务器，发送给客户端假的公钥）</p><h5 id="2、那有木有一种方式既可以安全的获取公钥，又能防止黑客冒充呢？-那就需要用到终极武器了：SSL-证书（申购）"><a href="#2、那有木有一种方式既可以安全的获取公钥，又能防止黑客冒充呢？-那就需要用到终极武器了：SSL-证书（申购）" class="headerlink" title="2、那有木有一种方式既可以安全的获取公钥，又能防止黑客冒充呢？ 那就需要用到终极武器了：SSL 证书（申购）"></a>2、那有木有一种方式既可以安全的获取公钥，又能防止黑客冒充呢？ 那就需要用到终极武器了：SSL 证书（申购）</h5><p><img src="https://pic1.zhimg.com/80/v2-5e2241fae8b593ff7f3b3a308ef81c10_720w.png" alt="http2"><br>如上图所示，在第 ② 步时服务器发送了一个SSL证书给客户端，SSL 证书中包含的具体内容有：</p></li><li><p>（1）证书的发布机构CA</p></li><li><p>（2）证书的有效期</p></li><li><p>（3）公钥</p></li><li><p>（4）证书所有者</p></li><li><p>（5）签名<br>………</p><h5 id="3、客户端在接受到服务端发来的SSL证书时，会对证书的真伪进行校验，以浏览器为例说明如下："><a href="#3、客户端在接受到服务端发来的SSL证书时，会对证书的真伪进行校验，以浏览器为例说明如下：" class="headerlink" title="3、客户端在接受到服务端发来的SSL证书时，会对证书的真伪进行校验，以浏览器为例说明如下："></a>3、客户端在接受到服务端发来的SSL证书时，会对证书的真伪进行校验，以浏览器为例说明如下：</h5><p>（1）首先浏览器读取证书中的证书所有者、有效期等信息进行一一校验<br>（2）浏览器开始查找操作系统中已内置的受信任的证书发布机构CA，与服务器发来的证书中的颁发者CA比对，用于校验证书是否为合法机构颁发<br>（3）如果找不到，浏览器就会报错，说明服务器发来的证书是不可信任的。<br>（4）如果找到，那么浏览器就会从操作系统中取出 颁发者CA 的公钥，然后对服务器发来的证书里面的签名进行解密<br>（5）浏览器使用相同的hash算法计算出服务器发来的证书的hash值，将这个计算的hash值与证书中签名做对比<br>（6）对比结果一致，则证明服务器发来的证书合法，没有被冒充<br>（7）此时浏览器就可以读取证书中的公钥，用于后续加密了</p><h5 id="4、所以通过发送SSL证书的形式，既解决了公钥获取问题，又解决了黑客冒充问题，一箭双雕，HTTPS加密过程也就此形成"><a href="#4、所以通过发送SSL证书的形式，既解决了公钥获取问题，又解决了黑客冒充问题，一箭双雕，HTTPS加密过程也就此形成" class="headerlink" title="4、所以通过发送SSL证书的形式，既解决了公钥获取问题，又解决了黑客冒充问题，一箭双雕，HTTPS加密过程也就此形成"></a>4、所以通过发送SSL证书的形式，既解决了公钥获取问题，又解决了黑客冒充问题，一箭双雕，HTTPS加密过程也就此形成</h5><p>所以相比HTTP，HTTPS 传输更加安全<br>（1） 所有信息都是加密传播，黑客无法窃听。<br>（2） 具有校验机制，一旦被篡改，通信双方会立刻发现。<br>（3） 配备身份证书，防止身份被冒充。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>综上所述，相比 HTTP 协议，HTTPS 协议增加了很多握手、加密解密等流程，虽然过程很复杂，但其可以保证数据传输的安全。所以在这个互联网膨胀的时代，其中隐藏着各种看不见的危机，为了保证数据的安全，维护网络稳定，建议大家多多推广HTTPS。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> https </tag>
            
            <tag> ssl </tag>
            
            <tag> 程序员 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单片机作业：期中</title>
      <link href="/2020/04/04/%E5%8D%95%E7%89%87%E6%9C%BA%E4%B8%AD/"/>
      <url>/2020/04/04/%E5%8D%95%E7%89%87%E6%9C%BA%E4%B8%AD/</url>
      
        <content type="html"><![CDATA[<h2 id="功能要求："><a href="#功能要求：" class="headerlink" title="功能要求："></a>功能要求：</h2><p>1.控制某运动工作台沿轴向运动，有前进和后退两个方向。</p><p>2.控制系统设计有三个按钮：一个是模式切换按钮，一个是“foward”按键，一个是“backward”按键。 </p><p>3.工作台两端设计各设计安排一个限位传感器。</p><p>4.系统有2种控制模式： </p><p>一种是点动控制，即“foward”按键按下时工作台前进动作，放手即停；“backward”按键按下时工作台后退动作，放手即停。 </p><p>第二种是自动动控制，即“foward”工作台前进/停止复用按键；“backward”工作台后退/停止复用按键。 </p><p>第三种是往复循环模式，即自动在两限位之间循环动作，“foward”按键作为启动按键，按下后工作台前进动作，遇到右侧限位自动反转运行，直到遇到左侧限位，然后又反向运行，如此往复运动，“backward”按键作为停止按键，按下后循环运动停止。</p><p>5.液晶显示系统工作状态，界面自拟。</p><p>6.电机在运动时不得切换控制模式。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>这题的主要难点就是怎么将一颗按钮用于三种用途？<br>目前的想法是将原有的一颗键上的flag用一个循环，使之有三种功能：例如flag=0时干什么；flag=1时做什么；flag=2时做什么；这样就需要一个num来做循环，num++来实现，0到2的循环；<br>这就有两种方式了，如下：</p><pre><code>第一种：for(num==0 ;num&lt;3;num++)第二种：while(1)        {            num++;            if(num=3)            num=0;        }</code></pre><p>按照上面的两种方式就可以解决掉所有问题了，其余的就自己看代码吧！</p><h2 id="具体过程代码："><a href="#具体过程代码：" class="headerlink" title="具体过程代码："></a>具体过程代码：</h2><pre><code>#include&lt;reg51.h&gt;#include&lt;1602lcd.h&gt;sbit signal1=P1^0; sbit signal2=P1^1;  // control portsbit forward=P1^2;sbit backward=P1^3;  //  two keyssbit control_mode=P1^4;sbit limit_l=P3^2;sbit limit_r=P3^3;unsigned char md[]={&quot;mode:&quot;};       //modeunsigned char st[]={&quot;status:&quot;};       //状态unsigned char au[]={&quot;auto&quot;};unsigned char ma[]={&quot;manu&quot;};unsigned char fd[]={&quot;fowd&quot;};unsigned char stp[]={&quot;stop&quot;};unsigned char bk[]={&quot;back&quot;};unsigned char lp[]={&quot;loop&quot;};int num;bit status=0;       //status=1 表示在动   =0  停止bit mode_flag;bit fwd_flag;bit bak_flag;bit limit_l_flag;bit limit_r_flag;bit limit_flag;void scan_key();void out_put();void check_limit();void check_limit1();void main(){    lcd_init();    lcd_pos(1,1);    lcdwrite_string(md);    lcd_pos(1,7);         lcdwrite_string(ma);    lcd_pos(2,1);    lcdwrite_string(st);    lcd_pos(2,9);    lcdwrite_string(stp);    while(1)    {      scan_key();      out_put();    }}void scan_key()        //z单键复用{        if(control_mode==0 &amp;&amp; status==0)    {        num++;        if(num==3)                    num=0;             while(control_mode==0);        if(num==0)         //手动        {            lcd_pos(1,7);            lcdwrite_string(ma);                }        if(num==1)         //自动        {            lcd_pos(1,7);            lcdwrite_string(au);                }        if(num==2)            //循环        {                    lcd_pos(1,7);            lcdwrite_string(lp);                }    }}void out_put(){     if(num==1)     //auto     {          if(forward==0 &amp;&amp; bak_flag==0 &amp;&amp; limit_r_flag==0 )          {            fwd_flag=~fwd_flag;            if(fwd_flag==1)            {                lcd_pos(1,16);                lcdwrite_zm(&#39; &#39;);                lcd_pos(2,9);                lcdwrite_string(fd);                signal1=1;                signal2=0;                status=1;                limit_l_flag=0;            }            else            {                lcd_pos(1,16);                lcdwrite_zm(&#39; &#39;);                lcd_pos(2,9);                lcdwrite_string(stp);                signal1=1;                signal2=1;                status=0;                                          }             while(forward==0);          }         else if(backward==0 &amp;&amp; fwd_flag==0 &amp;&amp; limit_l_flag==0 )          {            bak_flag=~bak_flag;            if(bak_flag==1)            {                lcd_pos(1,16);                lcdwrite_zm(&#39; &#39;);                lcd_pos(2,9);                lcdwrite_string(bk);                signal1=0;                signal2=1;                status=1;                limit_r_flag=0;            }            else            {                lcd_pos(1,16);                lcdwrite_zm(&#39; &#39;);                lcd_pos(2,9);                lcdwrite_string(stp);                signal1=1;                signal2=1;                status=0;                                          }           while(backward==0);          }          check_limit();         }  else if(num==0)         //manu    {          if(forward==0 &amp;&amp; limit_r_flag==0)          {            lcd_pos(1,16);            lcdwrite_zm(&#39; &#39;);            lcd_pos(2,9);            lcdwrite_string(fd);            signal1=1;            signal2=0;            status=1;            limit_l_flag=0;                      }         else if(backward==0 &amp;&amp; limit_l_flag==0)          {            lcd_pos(1,16);            lcdwrite_zm(&#39; &#39;);            lcd_pos(2,9);            lcdwrite_string(bk);            signal1=0;            signal2=1;            status=1;            limit_r_flag=0;          }          else          {            lcd_pos(1,16);            lcdwrite_zm(&#39; &#39;);            lcd_pos(2,9);            lcdwrite_string(stp);            signal1=1;            signal2=1;            status=0;          }          check_limit();    }    else if(num==2)    {            if(forward==0 &amp;&amp; status==0)        {            lcd_pos(1,16);            lcdwrite_zm(&#39; &#39;);            lcd_pos(2,9);            lcdwrite_string(fd);            signal1=1;            signal2=0;            status=1;            if(limit_r==0)            {                limit_flag=1;                signal1=0;                signal2=1;                status=1;            //有极限，触发后退                lcd_pos(1,16);                lcdwrite_zm(&#39;r&#39;);                lcd_pos(2,9);                lcdwrite_string(bk);                if(limit_l==0)                {                    limit_flag=1;                    signal1=1;                    signal2=0;                    status=1;                //左极限，触发前进                    lcd_pos(1,16);                    lcdwrite_zm(&#39;l&#39;);                    lcd_pos(2,9);                    lcdwrite_string(fd);                }            }        }        else if(backward==0)        {            lcd_pos(1,16);            lcdwrite_zm(&#39; &#39;);            lcd_pos(2,9);            lcdwrite_string(stp);            signal1=1;            signal2=1;            status=0;        }        check_limit1();    }}void check_limit(){    if(limit_l==0)    {        limit_l_flag=1; //左限制        signal1=1;        signal2=1;        status=0;        fwd_flag=0;        bak_flag=0;        lcd_pos(1,16);        lcdwrite_zm(&#39;l&#39;);        lcd_pos(2,9);        lcdwrite_string(stp);    }    if(limit_r==0)    {        limit_r_flag=1;     //右限制        signal1=1;        signal2=1;        status=0;        fwd_flag=0;        bak_flag=0;        lcd_pos(1,16);        lcdwrite_zm(&#39;r&#39;);        lcd_pos(2,9);        lcdwrite_string(stp);            }}void check_limit1(){    if(limit_l==0)    {        signal1=1;        signal2=0;        status=1;    //左极限，触发前进        lcd_pos(1,16);        lcdwrite_zm(&#39;l&#39;);        lcd_pos(2,9);        lcdwrite_string(fd);    }    if(limit_r==0)    {        signal1=0;        signal2=1;        status=1;    //右极限，触发后退        lcd_pos(1,16);        lcdwrite_zm(&#39;r&#39;);        lcd_pos(2,9);        lcdwrite_string(bk);            }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 单片机作业 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单片机 </tag>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo1</title>
      <link href="/2020/04/04/hexo1/"/>
      <url>/2020/04/04/hexo1/</url>
      
        <content type="html"><![CDATA[<h2 id="文章-Front-matter-介绍"><a href="#文章-Front-matter-介绍" class="headerlink" title="文章 Front-matter 介绍"></a>文章 Front-matter 介绍</h2><h3 id="Front-matter-选项详解"><a href="#Front-matter-选项详解" class="headerlink" title="Front-matter 选项详解"></a>Front-matter 选项详解</h3><blockquote><p>Front-matter 选项中的所有内容均为非必填的。但我仍然建议至少填写 title 和 date 的值。</p></blockquote><table><thead><tr><th>配置选项</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td>title</td><td>Markdown 的文件标题</td><td>文章标题，强烈建议填写此选项</td></tr><tr><td>date</td><td>文件创建时的日期时间</td><td>发布时间，强烈建议填写此选项，且最好保证全局唯一</td></tr><tr><td>author</td><td>根 _config.yml 中的 author</td><td>文章作者</td></tr><tr><td>img</td><td>featureImages 中的某个值</td><td>文章特征图，推荐使用图床(腾讯云、七牛云、又拍云等)来做图片的路径。如: <a href="http://xxx.com/xxx.jpg" target="_blank" rel="noopener">http://xxx.com/xxx.jpg</a></td></tr><tr><td>top</td><td>true</td><td>推荐文章（文章是否置顶），如果 top 值为 true，则会作为首页推荐文章</td></tr><tr><td>cover</td><td>false</td><td>v1.0.2版本新增，表示该文章是否需要加入到首页轮播封面中</td></tr><tr><td>coverImg</td><td>无</td><td>v1.0.2版本新增，表示该文章在首页轮播封面需要显示的图片路径，如果没有，则默认使用文章的特色图片</td></tr><tr><td>password</td><td>无</td><td>文章阅读密码，如果要对文章设置阅读验证密码的话，就可以设置 password 的值，该值必须是用 SHA256 加密后的密码，防止被他人识破。前提是在主题的 config.yml 中激活了 verifyPassword选项</td></tr><tr><td>toc</td><td>true</td><td>是否开启 TOC，可以针对某篇文章单独关闭 TOC 的功能。前提是在主题的 config.yml 中激活了 toc 选项</td></tr><tr><td>mathjax</td><td>false</td><td>是否开启数学公式支持 ，本文章是否开启 mathjax，且需要在主题的 _config.yml 文件中也需要开启才行</td></tr><tr><td>summary</td><td>无</td><td>文章摘要，自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要</td></tr><tr><td>categories</td><td>无</td><td>文章分类，本主题的分类表示宏观上大的分类，只建议一篇文章一个分类</td></tr><tr><td>tags</td><td>无</td><td>文章标签，一篇文章可以多个标签</td></tr><tr><td>reprintPolicy</td><td>cc_by</td><td>文章转载规则， 可以是 cc_by, cc_by_nd, cc_by_sa, cc_by_nc, cc_by_nc_nd, cc_by_nc_sa, cc0, noreprint 或 pay 中的一个</td></tr></tbody></table><h2 id="注意"><a href="#注意" class="headerlink" title="注意:"></a>注意:</h2><blockquote><p>如果 img 属性不填写的话，文章特色图会根据文章标题的 hashcode 的值取余，然后选取主题中对应的特色图片，从而达到让所有文章都的特色图各有特色。<br>date 的值尽量保证每篇文章是唯一的，因为本主题中 Gitalk 和 Gitment 识别 id 是通过 date 的值来作为唯一标识的。<br>如果要对文章设置阅读验证密码的功能，不仅要在 Front-matter 中设置采用了 SHA256 加密的 password 的值，还需要在主题的 _config.yml 中激活了配置。有些在线的 SHA256 加密的地址，可供你使用：开源中国在线工具、chahuo、站长工具。<br>您可以在文章md文件的 front-matter 中指定 reprintPolicy 来给单个文章配置转载规则。</p></blockquote><p>以下为文章的 Front-matter 示例。</p><h2 id="最简示例"><a href="#最简示例" class="headerlink" title="最简示例"></a>最简示例</h2><pre><code>---title: typora-vue-theme主题介绍date: 2020-04-04 09:25:00---</code></pre><pre><code>---title: typora-vue-theme主题介绍date: 2020-04-04 09:25:00author: 拜德英纳夫img: /source/images/xxx.jpgtop: truecover: truecoverImg: /images/1.jpgpassword: 8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92toc: falsemathjax: falsesummary: 这是你自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要categories: Markdowntags:  - Typora  - Markdown---</code></pre>]]></content>
      
      
      <categories>
          
          <category> 博客技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo博客 </tag>
            
            <tag> matery主题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单片机作业：7</title>
      <link href="/2020/04/03/%E5%8D%95%E7%89%87%E6%9C%BA7/"/>
      <url>/2020/04/03/%E5%8D%95%E7%89%87%E6%9C%BA7/</url>
      
        <content type="html"><![CDATA[<h2 id="课后项目设计功能要求："><a href="#课后项目设计功能要求：" class="headerlink" title="课后项目设计功能要求："></a>课后项目设计功能要求：</h2><p>1.控制某运动工作台沿轴向运动，有前进和后退两个方向。</p><p>2.控制系统设计有三个按钮：一个是模式切换按钮，一个是“foward”按键，一个是“backward”按键。</p><p>3.工作台两端设计各设计安排一个限位传感器。</p><p>4.系统有2种控制模式：</p><p>一种是点动控制，即“foward”按键按下时工作台前进动作，放手即停；“backward”按键按下时工作台后退动作，放手即停。</p><p>另一种是：自动在两限位之间循环动作，即“foward”按键作为启动按键，按下后工作台前进动作，遇到右侧限位自动反转运行，直到遇到左侧限位，然后又反向运行，如此往复运动，“backward”按键作为停止按键，按下后循环运动停止。</p><p>5.液晶显示系统工作状态，界面自拟。</p><p>6.电机在运动时不得切换控制模式。</p><p>7.触碰到限位开关时，要求用中断功能实现。</p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><blockquote><p>刚刚看到有个同学居然还要我把上次的作业也发一下，那我就直接发一下了。<br>章某人给钱！最后附有二维码！</p></blockquote><h2 id="直接上代码："><a href="#直接上代码：" class="headerlink" title="直接上代码："></a>直接上代码：</h2><pre><code>#include&lt;reg51.h&gt;#include&lt;1602lcd.h&gt;sbit signal1=P1^0;sbit signal2=P1^1;sbit forward=P1^2;sbit backward=P1^3;sbit control_mode=P1^4;unsigned char md[]={&quot;mode:&quot;};       //modeunsigned char st[]={&quot;status:&quot;};       //状态unsigned char au[]={&quot;auto&quot;};unsigned char ma[]={&quot;manu&quot;};unsigned char fd[]={&quot;fowd&quot;};unsigned char stp[]={&quot;stop&quot;};unsigned char bk[]={&quot;back&quot;};bit mode_flag;bit status;bit limit_flag;void scan_key();void output();void main(){//中断    EA=1;    EX0=1;    EX1=1;    IT0=1;    IT1=1;//显示器    lcd_init();    lcd_pos(1,1);    lcdwrite_string(md);    lcd_pos(1,7);         lcdwrite_string(ma);    lcd_pos(2,1);    lcdwrite_string(st);    lcd_pos(2,9);    lcdwrite_string(stp);    while(1)    {        scan_key();        output();    }}void scan_key(){        if(control_mode==0 &amp;&amp; status==0)    {        mode_flag=~mode_flag;        while(control_mode==0);        //加显示器的内容        if(mode_flag==0)  //手动模式         {            lcd_pos(1,7);                 lcdwrite_string(ma);         }         else             //自动模式         {            lcd_pos(1,7);                 lcdwrite_string(au);         }            }        }void output(){    if(mode_flag==1)         // auto    {        if(forward==0 &amp;&amp; status==0)        {            lcd_pos(1,16);            lcdwrite_zm(&#39; &#39;);            lcd_pos(2,9);            lcdwrite_string(fd);            signal1=1;            signal2=0;            status=1;        }        else if(backward==0)        {            lcd_pos(1,16);            lcdwrite_zm(&#39; &#39;);            lcd_pos(2,9);            lcdwrite_string(stp);            signal1=1;            signal2=1;            status=0;        }                }    else if(mode_flag==0)     // manu    {        if(forward==0 &amp;&amp; limit_flag==0)        {            lcd_pos(1,16);            lcdwrite_zm(&#39; &#39;);            lcd_pos(2,9);            lcdwrite_string(fd);            signal1=1;            signal2=0;            status=1;        }        else if(backward==0 &amp;&amp; limit_flag==0)        {            lcd_pos(1,16);            lcdwrite_zm(&#39; &#39;);            lcd_pos(2,9);            lcdwrite_string(bk);            signal1=0;            signal2=1;            status=1;        }        else        {            lcd_pos(1,16);            lcdwrite_zm(&#39; &#39;);            lcd_pos(2,9);            lcdwrite_string(stp);            signal1=1;            signal2=1;            status=0;        }    }}void check0() interrupt 0{    limit_flag=1;    signal1=1;    signal2=0;    status=1;//左极限，触发前进    lcd_pos(1,16);    lcdwrite_zm(&#39;l&#39;);    lcd_pos(2,9);    lcdwrite_string(fd);    } void check1() interrupt 2{    limit_flag=1;    signal1=0;    signal2=1;    status=1;//有极限，触发后退    lcd_pos(1,16);    lcdwrite_zm(&#39;r&#39;);    lcd_pos(2,9);    lcdwrite_string(bk);}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 单片机作业 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单片机 </tag>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单片机作业：8</title>
      <link href="/2020/04/03/%E5%8D%95%E7%89%87%E6%9C%BA8/"/>
      <url>/2020/04/03/%E5%8D%95%E7%89%87%E6%9C%BA8/</url>
      
        <content type="html"><![CDATA[<h2 id="老师给的要求"><a href="#老师给的要求" class="headerlink" title="老师给的要求"></a>老师给的要求</h2><p>1.控制运动工作台的两个电机均可沿轴向运动，有前进和后退两个方向。<br>2.每轴的电机都有2种控制模式：<br>一种是点动控制，即“foward”按键按下时工作台前进动作，放手即停；“backward”按键按下时工作台后退动作，放手即停。<br>另一种是：模态动作控制，即只要“foward”按键按下，工作台即发生前进动作，放手后依然保持前进动作，除非机床接到新的控制命令；即只要“backward”按键按下，工作台即发生后退动作，放手后依然保持后退动作，除非机床接到新的控制命令。<br>3.控制系统设计有四个按钮：一个是运动轴电机选择的切换按键，一个是模式切换按钮，一个是“foward”按键，一个是“backward”按键。 k1-k4这四个按键可由设计者根据设计功能要求自行分配。<br>3.工作台的每个运动轴两端各设计安排一个限位传感器，采用外部中断扩展方式设计，电路原理如图所示。<br>4.液晶显示系统工作状态，界面自拟。<br>5.电机在运动时不得切换控制模式。<br>6.触碰到限位开关时，要求用中断功能实现停止电机动作，并做液晶报警提醒。<br>7.其他个性化功能自拟。</p><h2 id="写代码过程"><a href="#写代码过程" class="headerlink" title="写代码过程"></a>写代码过程</h2><p>将原来的程序进行加工，现在只有一个控制端口，但是要实现4种控制，这种和上次的很想但是又有变化，将原来的设计重新做一下，再将新的信号接入，这样就可以了。<br>在运行过程中出现了很多问题，在设计之前以为就是小小的改变了一下，这次的代码量明显比之前多了很多，所以重新设计的量也大了。一开始出现了按钮按下电机可以转动，但是相互锁的只有一次机会，我找了好几久才发现，原来是一次限位之后没有释放第二次的机会，最后我还是解决了；还有的就是代码的量太大了，有点乱，我都搞混了，以后写代码后面必须加一些可以区分的标志物，这样方便修改和编辑。</p><p>这次的代码练习我做了一个下午，为什么时间那么长呢？是因为我找错误找了好久，本就已经找到代码错在哪里了，但是还是搞了那么久，不知道为什么就是有点乱，以后我知道了，在写代码后面必须要注释一些东西加以区分，这样方便以后修改和编辑。</p><h2 id="单片机代码："><a href="#单片机代码：" class="headerlink" title="单片机代码："></a>单片机代码：</h2><pre><code>#include&lt;reg51.h&gt;#include&lt;1602lcd.h&gt;sbit signal1=P1^0; sbit signal2=P1^1; sbit signal3=P1^7;sbit signal4=P2^7;    // control portsbit forward=P1^2;    sbit backward=P1^3; sbit run=P1^5;      //  four keyssbit control_mode=P1^4;sbit limit_1l=P2^3;        sbit limit_1r=P2^4;sbit limit_2l=P2^5;        sbit limit_2r=P2^6;     //four limits  unsigned char md[]={&quot;mode:&quot;};       unsigned char st[]={&quot;status:&quot;};       //状态unsigned char au[]={&quot;auto&quot;};unsigned char ma[]={&quot;manu&quot;};unsigned char fd[]={&quot;fowd&quot;};unsigned char bk[]={&quot;back&quot;};unsigned char stp[]={&quot;stop&quot;};unsigned char x[]={&quot;x&quot;};unsigned char y[]={&quot;y&quot;};bit status=0;       //status=1 动 0 停止bit mode_flag;bit fd_flag;bit bk_flag;bit run_flag;bit fd_flag2;bit bk_flag2;bit limit_1l_flag;  //限位标志位bit limit_1r_flag;bit limit_2l_flag;bit limit_2r_flag;void scan_key();void out_put();void scan_key2();void main(){    lcd_init();    lcd_pos(1,1);    lcdwrite_string(md);    lcd_pos(1,7);         lcdwrite_string(ma);    lcd_pos(2,1);    lcdwrite_string(st);    lcd_pos(2,9);    lcdwrite_string(stp);        lcd_pos(2,14);    lcdwrite_string(x);    EA=1;    EX0=1;    EX1=1;    IT0=1;    IT1=1;    while(1)    {      scan_key();      scan_key2();      out_put();    }                    }void scan_key()        //mode单键复用{   if(run==0 &amp;&amp; status==0)   {     run_flag=~run_flag;     if(run_flag==0)  //x模式     {            lcd_pos(2,14);            lcdwrite_string(x);     }     else             //y模式     {            lcd_pos(2,14);            lcdwrite_string(y);     }          while(run==0);   }}void scan_key2(){    if(control_mode==0 &amp;&amp; status==0)   {     mode_flag=~mode_flag;     if(mode_flag==0)  //手动模式     {            lcd_pos(1,7);                 lcdwrite_string(ma);     }     else             //自动模式     {            lcd_pos(1,7);                 lcdwrite_string(au);     }          while(control_mode==0);   }}void out_put(){    if(run_flag==0)        //X轴    {              if(mode_flag==1)    //自动模态         {              if(forward==0 &amp;&amp; bk_flag==0 &amp;&amp; limit_1r_flag==0 )                  {                        fd_flag=~fd_flag;                    if(fd_flag==1)                    {                        lcd_pos(1,16);                        lcdwrite_zm(&#39; &#39;);                        lcd_pos(2,9);                        lcdwrite_string(fd);                                            signal1=1;                        signal2=0;                        status=1;                    }                    else                    {                        lcd_pos(1,16);                        lcdwrite_zm(&#39; &#39;);                        lcd_pos(2,9);                        lcdwrite_string(stp);                        signal1=1;                        signal2=1;                        status=0;                    }                    while(forward==0);              }             if(backward==0 &amp;&amp; fd_flag==0 &amp;&amp; limit_1l_flag==0 )              {                                bk_flag=~bk_flag;                    if(bk_flag==1)                    {                        lcd_pos(1,16);                        lcdwrite_zm(&#39; &#39;);                        lcd_pos(2,9);                        lcdwrite_string(bk);                        signal1=0;                        signal2=1;                        status=1;                    }                    else                    {                        lcd_pos(1,16);                        lcdwrite_zm(&#39; &#39;);                        lcd_pos(2,9);                        lcdwrite_string(stp);                        signal1=1;                        signal2=1;                        status=0;                                                  }                     while(backward==0);              }             }      else if(mode_flag==0)    //手动        {              if(forward==0 &amp;&amp; limit_1r_flag==0)                  {                    lcd_pos(1,16);                    lcdwrite_zm(&#39; &#39;);                    lcd_pos(2,9);                    lcdwrite_string(fd);                                        signal1=1;                    signal2=0;                    status=1;                    limit_1l_flag=0;                              }             else if(backward==0 &amp;&amp; limit_1l_flag==0)              {                    lcd_pos(1,16);                    lcdwrite_zm(&#39; &#39;);                    lcd_pos(2,9);                    lcdwrite_string(bk);                    signal1=0;                    signal2=1;                    status=1;                    limit_1r_flag=0;                              }              else              {                    lcd_pos(1,16);                    lcdwrite_zm(&#39; &#39;);                    lcd_pos(2,9);                    lcdwrite_string(stp);                    signal1=1;                    signal2=1;                    status=0;              }        }    }    else if(run_flag==1)     //Y轴    {         if(mode_flag==1)    //自动模态         {              if(forward==0 &amp;&amp; bk_flag2==0)                  {                        fd_flag2=~fd_flag2;                    if(fd_flag2==1)                    {                        lcd_pos(1,16);                        lcdwrite_zm(&#39; &#39;);                        lcd_pos(2,9);                        lcdwrite_string(fd);                                            signal3=1;                        signal4=0;                        status=1;                        limit_2l_flag=0;                    }                    else                    {                        lcd_pos(1,16);                        lcdwrite_zm(&#39; &#39;);                        lcd_pos(2,9);                        lcdwrite_string(stp);                        signal3=1;                        signal4=1;                        status=0;                    }                    while(forward==0);              }             if(backward==0 &amp;&amp; fd_flag2==0)              {                                bk_flag2=~bk_flag2;                    if(bk_flag2==1 )                    {                        lcd_pos(1,16);                        lcdwrite_zm(&#39; &#39;);                        lcd_pos(2,9);                        lcdwrite_string(bk);                        signal3=0;                        signal4=1;                        status=1;                        limit_2r_flag=0;                    }                    else                    {                        lcd_pos(1,16);                        lcdwrite_zm(&#39; &#39;);                        lcd_pos(2,9);                        lcdwrite_string(stp);                        signal3=1;                        signal4=1;                        status=0;                                                  }                     while(backward==0);              }             }      else if(mode_flag==0)    //手动        {              if(forward==0 &amp;&amp; limit_2r_flag==0)                  {                    lcd_pos(1,16);                    lcdwrite_zm(&#39; &#39;);                    lcd_pos(2,9);                    lcdwrite_string(fd);                                        signal3=1;                    signal4=0;                    status=1;                              }             else if(backward==0 &amp;&amp; limit_2l_flag==0)              {                    lcd_pos(1,16);                    lcdwrite_zm(&#39; &#39;);                    lcd_pos(2,9);                    lcdwrite_string(bk);                    signal3=0;                    signal4=1;                    status=1;                              }              else              {                    lcd_pos(1,16);                    lcdwrite_zm(&#39; &#39;);                    lcd_pos(2,9);                    lcdwrite_string(stp);                    signal3=1;                    signal4=1;                    status=0;              }        }    }}void int_int0() interrupt 0{    if(run_flag==0)           // X    {        if(mode_flag==0)        {           if(limit_1l==0)           {                limit_1l_flag=1;                limit_1r_flag=0;                            signal1=0;                signal2=0;                lcd_pos(1,16);                lcdwrite_zm(&#39;l&#39;);                lcd_pos(2,9);                lcdwrite_string(stp);                status=0;            }           else if(limit_1r==0)           {                   limit_1r_flag=1;                limit_1l_flag=0;                            signal1=0;                signal2=0;                lcd_pos(1,16);                lcdwrite_zm(&#39;r&#39;);                lcd_pos(2,9);                lcdwrite_string(stp);                status=0;           }                                                                }          else          {                  if(limit_1l==0)           {                limit_1l_flag=1;                limit_1r_flag=0;                signal1=0;                signal2=0;                                fd_flag=0;                bk_flag=0;                lcd_pos(1,16);                lcdwrite_zm(&#39;l&#39;);                lcd_pos(2,9);                lcdwrite_string(stp);                status=0;            }           else if(limit_1r==0)           {                   limit_1r_flag=1;                limit_1l_flag=0;                signal1=0;                signal2=0;                fd_flag=0;                bk_flag=0;                                                lcd_pos(1,16);                lcdwrite_zm(&#39;r&#39;);                lcd_pos(2,9);                lcdwrite_string(stp);                status=0;           }             }    }    else             // Y    {        if(mode_flag==0)       //手动        {              if(limit_2l==0)              {                    limit_2l_flag=1;                    limit_2r_flag=0;                                                    signal3=0;                    signal4=0;                        lcd_pos(1,16);                    lcdwrite_zm(&#39;l&#39;);                    lcd_pos(2,9);                    lcdwrite_string(stp);                    status=0;              }              else if(limit_2r==0)              {                       limit_2r_flag=1;                    limit_2l_flag=0;                                signal3=0;                    signal4=0;                        lcd_pos(1,16);                    lcdwrite_zm(&#39;r&#39;);                    lcd_pos(2,9);                    lcdwrite_string(stp);                    status=0;              }                                                                }        else              //自动        {                  if(limit_2l==0)           {                limit_2l_flag=1;                limit_2r_flag=0;                signal3=0;                signal4=0;                                fd_flag2=0;                bk_flag2=0;                lcd_pos(1,16);                lcdwrite_zm(&#39;l&#39;);                lcd_pos(2,9);                lcdwrite_string(stp);                status=0;            }           else if(limit_2r==0)           {                   limit_2r_flag=1;                limit_2l_flag=0;                signal3=0;                signal4=0;                fd_flag2=0;                bk_flag2=0;                                                lcd_pos(1,16);                lcdwrite_zm(&#39;r&#39;);                lcd_pos(2,9);                lcdwrite_string(stp);                status=0;           }           }                    }        }</code></pre>]]></content>
      
      
      <categories>
          
          <category> 单片机作业 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单片机 </tag>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一篇文章多个categories</title>
      <link href="/2020/04/02/hexo2/"/>
      <url>/2020/04/02/hexo2/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在很多情况下，我们希望在 Hexo 中写的一篇文章能够同时属于多个分类， 例如我写一篇 《Servlet笔记》，我既想将它放在 Java 这个分类中，又想将它放入 Servlet 这个分类。</p><p>按照官方的解释，categories 这个选项有两种配置方法（其实有三种）。那我们就来讲讲这三种配置方法。</p><h2 id="子分类"><a href="#子分类" class="headerlink" title="子分类"></a>子分类</h2><p>下面的分类会将该分章放到 Java/Servlet这个分类下。</p><pre><code>categories:  - Java  - Servlet</code></pre><p>同样的作用我们也可以这样写。</p><pre><code>    categories: [Java, Servlet]</code></pre><p>上面两种方法最终效果一样，都是将文章放在了一个子分类的目录下。</p><h2 id="多个分类"><a href="#多个分类" class="headerlink" title="多个分类"></a>多个分类</h2><p>如果我们的要求是将文章同时分到多个不同的分类中呢，我们应该这样：</p><pre><code>categories:-[Java]-[Servlet]</code></pre><p>这样，就可以将上面的文章分类到 Java 和 Servlet 这两个不同的目录中了。<br>扩展一下，如果我们将其分类到 Java/Servlet 和 Programming 两个不同的目录下，我们应该如下写：</p><pre><code>categories:-[Java, Servlet]-[Programming]</code></pre>]]></content>
      
      
      <categories>
          
          <category> 博客技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo博客 </tag>
            
            <tag> next主题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我在hexo博客自己写的第一篇文章</title>
      <link href="/2020/04/02/secondone/"/>
      <url>/2020/04/02/secondone/</url>
      
        <content type="html"><![CDATA[<h2 id="随便聊聊"><a href="#随便聊聊" class="headerlink" title="随便聊聊"></a>随便聊聊</h2><p>这个博客是我在业余时间学习搭建的，这个是基于Hexo博客系统搭建的，再加上github的代码管理工具，这样就是相当于免费的，多就是需要大量的时间去维护和使用；</p><h2 id="另一个网站"><a href="#另一个网站" class="headerlink" title="另一个网站"></a>另一个网站</h2><p>如果你还是喜欢看简单一点的，还是去我的另一个主要的博客看吧！<br>地址：<a href="http://118.178.84.132:8090/" target="_blank" rel="noopener">http://118.178.84.132:8090/</a></p>]]></content>
      
      
      <categories>
          
          <category> 随笔录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo博客 </tag>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown 教程</title>
      <link href="/2020/02/29/markdown1/"/>
      <url>/2020/02/29/markdown1/</url>
      
        <content type="html"><![CDATA[<h2 id="Markdown-标题"><a href="#Markdown-标题" class="headerlink" title="Markdown 标题"></a>Markdown 标题</h2><p>Markdown 标题有两种格式。</p><p>###1、使用 = 和 - 标记一级和二级标题<br>= 和 - 标记语法格式如下：</p><pre><code>我展示的是一级标题=================我展示的是二级标题-----------------</code></pre><h3 id="使用-号标记"><a href="#使用-号标记" class="headerlink" title="使用 # 号标记"></a>使用 # 号标记</h3><p>使用 # 号可表示 1-6 级标题，一级标题对应一个 # 号，二级标题对应两个 # 号，以此类推。</p><pre><code># 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题</code></pre><h2 id="Markdown-段落"><a href="#Markdown-段落" class="headerlink" title="Markdown 段落"></a>Markdown 段落</h2><p>Markdown 段落没有特殊的格式，直接编写文字就好，段落的换行是使用两个以上空格加上回车。<br>当然也可以在段落后面使用一个空行来表示重新开始一个段落。</p><h3 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h3><p>Markdown 可以使用以下几种字体：</p><pre><code>*斜体文本*_斜体文本_**粗体文本**__粗体文本__***粗斜体文本***___粗斜体文本___</code></pre><h3 id="分隔线"><a href="#分隔线" class="headerlink" title="分隔线"></a>分隔线</h3><p>你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线：</p><pre><code>**** * ******- - -----------</code></pre><h3 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h3><p>如果段落上的文字要添加删除线，只需要在文字的两端加上两个波浪线 ~~ 即可，实例如下：</p><pre><code>Badenough.COMGOOGLE.COM~~BAIDU.COM~~</code></pre><h3 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a>下划线</h3><p>下划线可以通过 HTML 的 <code>&lt;u&gt;</code>标签来实现：</p><pre><code>&lt;u&gt;带下划线文本&lt;/u&gt;</code></pre><h3 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h3><p>脚注是对文本的补充说明。<br>Markdown 脚注的格式如下:</p><pre><code>[^要注明的文本]</code></pre><p>以下实例演示了脚注的用法：</p><pre><code>创建脚注格式类似这样 [^Badenough]。[^Badenough]: 学习 -- 学的不仅是技术，更是梦想！！！</code></pre><h2 id="Markdown-列表"><a href="#Markdown-列表" class="headerlink" title="Markdown 列表"></a>Markdown 列表</h2><p>Markdown 支持有序列表和无序列表。<br>无序列表使用星号(*)、加号(+)或是减号(-)作为列表标记：</p><pre><code>* 第一项* 第二项* 第三项+ 第一项+ 第二项+ 第三项- 第一项- 第二项- 第三项</code></pre><p>有序列表使用数字并加上 . 号来表示，如：</p><pre><code>1. 第一项2. 第二项3. 第三项</code></pre><h3 id="列表嵌套"><a href="#列表嵌套" class="headerlink" title="列表嵌套"></a>列表嵌套</h3><p>列表嵌套只需在子列表中的选项添加四个空格即可：</p><pre><code>1. 第一项：    - 第一项嵌套的第一个元素    - 第一项嵌套的第二个元素2. 第二项：    - 第二项嵌套的第一个元素    - 第二项嵌套的第二个元素</code></pre><h2 id="Markdown-区块"><a href="#Markdown-区块" class="headerlink" title="Markdown 区块"></a>Markdown 区块</h2><h3 id="Markdown-区块引用是在段落开头使用-gt-符号-，然后后面紧跟一个空格符号："><a href="#Markdown-区块引用是在段落开头使用-gt-符号-，然后后面紧跟一个空格符号：" class="headerlink" title="Markdown 区块引用是在段落开头使用 &gt; 符号 ，然后后面紧跟一个空格符号："></a>Markdown 区块引用是在段落开头使用 &gt; 符号 ，然后后面紧跟一个空格符号：</h3><pre><code>&gt; 区块引用&gt; 菜鸟教程&gt; 学的不仅是技术更是梦想</code></pre><h3 id="另外区块是可以嵌套的，一个-gt-符号是最外层，两个-gt-符号是第一层嵌套，以此类推："><a href="#另外区块是可以嵌套的，一个-gt-符号是最外层，两个-gt-符号是第一层嵌套，以此类推：" class="headerlink" title="另外区块是可以嵌套的，一个 &gt; 符号是最外层，两个 &gt; 符号是第一层嵌套，以此类推："></a>另外区块是可以嵌套的，一个 &gt; 符号是最外层，两个 &gt; 符号是第一层嵌套，以此类推：</h3><pre><code>&gt; 最外层&gt; &gt; 第一层嵌套&gt; &gt; &gt; 第二层嵌套</code></pre><h3 id="区块中使用列表"><a href="#区块中使用列表" class="headerlink" title="区块中使用列表"></a>区块中使用列表</h3><p>区块中使用列表实例如下：</p><pre><code>&gt; 区块中使用列表&gt; 1. 第一项&gt; 2. 第二项&gt; + 第一项&gt; + 第二项&gt; + 第三项</code></pre><h3 id="列表中使用区块"><a href="#列表中使用区块" class="headerlink" title="列表中使用区块"></a>列表中使用区块</h3><p>如果要在列表项目内放进区块，那么就需要在 <code>&gt;</code>前添加四个空格的缩进。</p><p>区块中使用列表实例如下：</p><pre><code>* 第一项    &gt; 菜鸟教程    &gt; 学的不仅是技术更是梦想* 第二项</code></pre><h2 id="Markdown-代码"><a href="#Markdown-代码" class="headerlink" title="Markdown 代码"></a>Markdown 代码</h2><p>如果是段落上的一个函数或片段的代码可以用反引号把它包起来（`），例如：</p><pre><code> `printf()` 函数</code></pre><h3 id="代码区块"><a href="#代码区块" class="headerlink" title="代码区块"></a>代码区块</h3><p>代码区块使用 4 个空格或者一个制表符（Tab 键）。</p><h3 id="你也可以用-包裹一段代码，并指定一种语言（也可以不指定）："><a href="#你也可以用-包裹一段代码，并指定一种语言（也可以不指定）：" class="headerlink" title="你也可以用 ``` 包裹一段代码，并指定一种语言（也可以不指定）："></a>你也可以用 ``` 包裹一段代码，并指定一种语言（也可以不指定）：</h3><pre><code>` ` `javascript$(document).ready(function () {   alert(&#39;Badenough&#39;);});` ` `</code></pre><h2 id="Markdown-链接"><a href="#Markdown-链接" class="headerlink" title="Markdown 链接"></a>Markdown 链接</h2><p>链接使用方法如下：</p><pre><code>[链接名称](链接地址)或者&lt;链接地址&gt;</code></pre><p>例如：</p><pre><code>这是一个链接 [拜德英纳夫](https://zjt.ilovea.asia)</code></pre><p>直接使用链接地址：</p><pre><code>&lt;https://zjt.ilovea.asia&gt;</code></pre><h3 id="高级链接"><a href="#高级链接" class="headerlink" title="高级链接"></a>高级链接</h3><p>我们可以通过变量来设置一个链接，变量赋值在文档末尾进行：</p><pre><code>这个链接用 1 作为网址变量 [Google][1]这个链接用 Badenough 作为网址变量 [Badenough][badenough]然后在文档的结尾为变量赋值（网址）  [1]: http://www.google.com/  [badenough]: https://zjt.ilovea.asia</code></pre><h2 id="Markdown-图片"><a href="#Markdown-图片" class="headerlink" title="Markdown 图片"></a>Markdown 图片</h2><p>Markdown 图片语法格式如下：</p><pre><code>![alt 属性文本](图片地址)![alt 属性文本](图片地址 &quot;可选标题&quot;)</code></pre><ul><li>开头一个感叹号 !</li><li>接着一个方括号，里面放上图片的替代文字</li><li>接着一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上选择性的 ‘title’ 属性的文字。</li></ul><p>使用实例：</p><pre><code>![Badenough 图标](http://zjt.ilovea.asia/images/badenough-logo.png)![Badenough 图标](http://zjt.ilovea.asia/images/badenough-logo.png &quot;Badenough&quot;)</code></pre><h3 id="当然，你也可以像网址那样对图片网址使用变量"><a href="#当然，你也可以像网址那样对图片网址使用变量" class="headerlink" title="当然，你也可以像网址那样对图片网址使用变量:"></a>当然，你也可以像网址那样对图片网址使用变量:</h3><pre><code>这个链接用 1 作为网址变量 [Badenough][1].然后在文档的结尾为变量赋值（网址）[1]: http://zjt.ilovea.asia/images/badenough-logo.png</code></pre><p>Markdown 还没有办法指定图片的高度与宽度，如果你需要的话，你可以使用普通的 <img> 标签。</p><pre><code>&lt;img src=&quot;http://zjt.ilovea.asia/images/badenough-logo.png&quot; width=&quot;50%&quot;&gt;</code></pre><h2 id="Markdown-表格"><a href="#Markdown-表格" class="headerlink" title="Markdown 表格"></a>Markdown 表格</h2><p>Markdown 制作表格使用 | 来分隔不同的单元格，使用 - 来分隔表头和其他行。<br>语法格式如下：</p><pre><code>|  表头   | 表头  ||  ----  | ----  || 单元格  | 单元格 || 单元格  | 单元格 |</code></pre><h3 id="对齐方式"><a href="#对齐方式" class="headerlink" title="对齐方式"></a>对齐方式</h3><p>我们可以设置表格的对齐方式：</p><pre><code>-: 设置内容和标题栏居右对齐。:- 设置内容和标题栏居左对齐。:-: 设置内容和标题栏居中对齐。</code></pre><h2 id="Markdown-高级技巧"><a href="#Markdown-高级技巧" class="headerlink" title="Markdown 高级技巧"></a>Markdown 高级技巧</h2><h3 id="支持的-HTML-元素"><a href="#支持的-HTML-元素" class="headerlink" title="支持的 HTML 元素"></a>支持的 HTML 元素</h3><p>不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。<br>目前支持的 HTML 元素有：<code>&lt;kbd&gt; &lt;b&gt; &lt;i&gt; &lt;em&gt; &lt;sup&gt; &lt;sub&gt; &lt;br&gt;</code>等 ，如：</p><blockquote><p>使用 <code>&lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;Alt&lt;/kbd&gt;+&lt;kbd&gt;Del&lt;/kbd&gt;</code> 重启电脑</p></blockquote><h3 id="转义"><a href="#转义" class="headerlink" title="转义"></a>转义</h3><p>Markdown使用了很多特殊符号来表示特定的意义，如果需要显示特定的符号则需要使用转义字符，Markdown 使用反斜杠转义特殊字符：</p><pre><code>**文本加粗** \*\* 正常显示星号 \*\*</code></pre><p>Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号：</p><pre><code>\   反斜线`   反引号*   星号_   下划线{}  花括号[]  方括号()  小括号#   井字号+   加号-   减号.   英文句点!   感叹号</code></pre><h3 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h3><p>当你需要在编辑器中插入数学公式时，可以使用两个美元符 $$ 包裹 TeX 或 LaTeX 格式的数学公式来实现。提交后，问答和文章页会根据需要加载 Mathjax 对数学公式进行渲染。如：</p><pre><code>$$\mathbf{V}_1 \times \mathbf{V}_2 =  \begin{vmatrix} \mathbf{i} &amp; \mathbf{j} &amp; \mathbf{k} \\\frac{\partial X}{\partial u} &amp;  \frac{\partial Y}{\partial u} &amp; 0 \\\frac{\partial X}{\partial v} &amp;  \frac{\partial Y}{\partial v} &amp; 0 \\\end{vmatrix}${$tep1}{\style{visibility:hidden}{(x+1)(x+1)}}$$</code></pre><h2 id="typora-画流程图、时序图-顺序图-、甘特图"><a href="#typora-画流程图、时序图-顺序图-、甘特图" class="headerlink" title="typora 画流程图、时序图(顺序图)、甘特图"></a>typora 画流程图、时序图(顺序图)、甘特图</h2><h3 id="1、横向流程图源码格式："><a href="#1、横向流程图源码格式：" class="headerlink" title="1、横向流程图源码格式："></a>1、横向流程图源码格式：</h3><pre><code class="mermaid">graph LRA[方形] --&gt;B(圆角)    B --&gt; C{条件a}    C --&gt;|a=1| D[结果1]    C --&gt;|a=2| E[结果2]    F[横向流程图]</code></pre><h3 id="2、竖向流程图源码格式："><a href="#2、竖向流程图源码格式：" class="headerlink" title="2、竖向流程图源码格式："></a>2、竖向流程图源码格式：</h3><pre><code class="mermaid">graph TDA[方形] --&gt; B(圆角)    B --&gt; C{条件a}    C --&gt; |a=1| D[结果1]    C --&gt; |a=2| E[结果2]    F[竖向流程图]</code></pre><h3 id="3、标准流程图源码格式："><a href="#3、标准流程图源码格式：" class="headerlink" title="3、标准流程图源码格式："></a>3、标准流程图源码格式：</h3><pre><code class="flow">st=&gt;start: 开始框op=&gt;operation: 处理框cond=&gt;condition: 判断框(是或否?)sub1=&gt;subroutine: 子流程io=&gt;inputoutput: 输入输出框e=&gt;end: 结束框st-&gt;op-&gt;condcond(yes)-&gt;io-&gt;econd(no)-&gt;sub1(right)-&gt;op</code></pre><h3 id="4、标准流程图源码格式（横向）："><a href="#4、标准流程图源码格式（横向）：" class="headerlink" title="4、标准流程图源码格式（横向）："></a>4、标准流程图源码格式（横向）：</h3><pre><code class="flow">st=&gt;start: 开始框op=&gt;operation: 处理框cond=&gt;condition: 判断框(是或否?)sub1=&gt;subroutine: 子流程io=&gt;inputoutput: 输入输出框e=&gt;end: 结束框st(right)-&gt;op(right)-&gt;condcond(yes)-&gt;io(bottom)-&gt;econd(no)-&gt;sub1(right)-&gt;op</code></pre><h3 id="5、UML时序图源码样例："><a href="#5、UML时序图源码样例：" class="headerlink" title="5、UML时序图源码样例："></a>5、UML时序图源码样例：</h3><pre><code class="sequence">对象A-&gt;对象B: 对象B你好吗?（请求）Note right of 对象B: 对象B的描述Note left of 对象A: 对象A的描述(提示)对象B--&gt;对象A: 我很好(响应)对象A-&gt;对象B: 你真的好吗？</code></pre><h3 id="6、UML时序图源码复杂样例："><a href="#6、UML时序图源码复杂样例：" class="headerlink" title="6、UML时序图源码复杂样例："></a>6、UML时序图源码复杂样例：</h3><pre><code class="sequence">Title: 标题：复杂使用对象A-&gt;对象B: 对象B你好吗?（请求）Note right of 对象B: 对象B的描述Note left of 对象A: 对象A的描述(提示)对象B--&gt;对象A: 我很好(响应)对象B-&gt;小三: 你好吗小三--&gt;&gt;对象A: 对象B找我了对象A-&gt;对象B: 你真的好吗？Note over 小三,对象B: 我们是朋友participant CNote right of C: 没人陪我玩</code></pre><h3 id="7、UML标准时序图样例："><a href="#7、UML标准时序图样例：" class="headerlink" title="7、UML标准时序图样例："></a>7、UML标准时序图样例：</h3><pre><code class="mermaid">%% 时序图例子,-&gt; 直线，--&gt;虚线，-&gt;&gt;实线箭头  sequenceDiagram    participant 张三    participant 李四    张三-&gt;王五: 王五你好吗？    loop 健康检查        王五-&gt;王五: 与疾病战斗    end    Note right of 王五: 合理 食物 &lt;br/&gt;看医生...    李四--&gt;&gt;张三: 很好!    王五-&gt;李四: 你怎么样?    李四--&gt;王五: 很好!</code></pre><h3 id="8、甘特图样例："><a href="#8、甘特图样例：" class="headerlink" title="8、甘特图样例："></a>8、甘特图样例：</h3><pre><code class="mermaid">%% 语法示例        gantt        dateFormat  YYYY-MM-DD        title 软件开发甘特图        section 设计        需求                      :done,    des1, 2014-01-06,2014-01-08        原型                      :active,  des2, 2014-01-09, 3d        UI设计                     :         des3, after des2, 5d    未来任务                     :         des4, after des3, 5d        section 开发        学习准备理解需求                      :crit, done, 2014-01-06,24h        设计框架                             :crit, done, after des2, 2d        开发                                 :crit, active, 3d        未来任务                              :crit, 5d        耍                                   :2d        section 测试        功能测试                              :active, a1, after des3, 3d        压力测试                               :after a1  , 20h        测试报告                               : 48h</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>只要你认真学习了上面的所有操作步骤，你想失败都不可能了！！</p>]]></content>
      
      
      <categories>
          
          <category> Markdown应用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2020/02/28/hello-world/"/>
      <url>/2020/02/28/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
